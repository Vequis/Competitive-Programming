// h(k) -> função que mapeia as chaves
// h: U -> {0, 1, ..., m-1}

h(x)
    return x.chave mod 701

Hash-Insert(T, x) // x é um elemento
    j = h(x.chave)

    repeat
        if(T[j] == NIL or T[j] == DELETED)
            T[j] = x
            return j
        else 
            j = (j+1)mod 701
    until j == x.chave

    error "overflow"

Hash-Search(T, k) //k é uma chave
    j = h(k)

    if T[j] == NIL
        return NIL

    repeat
        if (T[j] != DELETED and T[j].chave == k)
            return T[j]
        else j = (j+1) mod 701

    until j==h(k) or T[j] == NIL

    return NIL

Hash-Delete(T, x)
    //Hash-Search(T, x.chave)
    j = h(x.chave)

    if T[j] == NIL
        return NIL

    repeat
        if (T[j].chave == k)
            T[j] = DELETED 
            return j
        else j = (j+1) mod 701

    until j==h(x.chave) or T[j] == NIL

    return NIL

//Lista Ligada

Chained-Hash-Insert(T, e)
    j = h(e.chave)
    e.proximo = T[j].inicio
    T[j].inicio = e

Chained-Hash-Search(T, k)
    j = h(k)
    atual = T[j].inicio
    while atual != NIL and atual.chave != k
        atual = atual.proximo
    return atual

Chained-Hash-Delete(T, e) //Supondo que o elemento e de fato exista na lista ligada
    j = h(e.chave)
    atual = T[j].inicio
    if T[j].inicio == e
        T[j].inicio = NIL
    else 
        while atual.proximo != e
            atual = atual.proximo
        atual.proximo = atual.proximo.proximo
    
